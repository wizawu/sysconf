`range`比下标快(边界检查)

在满足以下条件时，变量`v`可出现在`:=`声明中，即使该变量已被声明：

  * 该声明的作用域与已存在的`v`的声明作用域相同（若`v`已在外层的作用域中声明，则会创建一个新的变量），
  * 在初始化中相应类型的值才能赋予`v`，并且
  * 在声明中**至少有另一个变量是新声明的**。

`switch`并不会自动贯穿，但多个分支可通过**逗号分隔的列表**来呈现。

被推迟函数的实参（如果该函数为方法则还包括接收者）在**延期**执行时就会求值， 而不是在**调用**执行时才求值。

**返回一个局部变量的地址**完全没有问题，这点与C不同，**与此变量对应的存储在函数返回后仍然存在**。

以下为在Go和C中的数组的主要区别，在Go中，

  * 数组是值。将一个数组赋予另一个数组将复制其所有元素。
  * 特别地，如果你将一个数组传递给一个函数，它将接收到该数组的一个副本， 而不是指向它的指针。
  * 数组的大小是其类型的一部分。类型`[10]int`和`[20]int`是不同的。

切片不能用作映射键，因为它们的相等性还未定义。

如果试图使用一个不存在的键来获取映射值，就会返回在该映射对应该项类型的**零值**。

该包中的所有变量声明在求得其初始值后`init`才会被调用，而求值的工作则是在所有被导入的包都初始化后才开始进行的。

**字符串是不可变的**： 一旦被创建，字符串的内容就不能更改。

获取这样一个元素的地址是非法的；若`s[i]`为字符串的第`i`个字节，`&s[i]`就是无效的。

在数组、切片或映射类型`T`的复合字面中，若其元素本身亦为复合字面， 且该复合字面的元素类型与`T`的相同，则可省略其各自的元素类型。 类似地，当元素类型为`*T`时，若其元素为复合字面的地址，则可省略`&T`。
<pre><code>[...]Point{{1.5, -3.5}, {0, 0}}   // 等价于 [...]Point{Point{1.5, -3.5}, Point{0, 0}}
[][]int{{1, 2, 3}, {4, 5}}        // 等价于 [][]int{[]int{1, 2, 3}, []int{4, 5}}

[...]*Point{{1.5, -3.5}, {0, 0}}  // 等价于 [...]*Point{&Point{1.5, -3.5}, &Point{0, 0}}</code></pre>

当复合字面使用字面类型的类型名形式时，若它出现在关键字`if`、`for`或`switch`语句及其开大括号之间，就会产生解析歧义。因为在该字面中， 表达式外围的大括号会和那些语句块前的混淆。为解决此罕见情况中的歧义，该复合字面必须出现在小括号中。
<pre><code>if x == (T{a,b,c}[i]) { … }
if (x == T{a,b,c}[i]) { … }</code></pre>

有效的数组、切片和映射字面的例子：
<pre><code>// 若 ch 为元音则 vowels[ch] 为 true
vowels := [128]bool{'a': true, 'e': true, 'i': true, 'o': true, 'u': true, 'y': true}

// 数组 [10]float32{-1, 0, 0, 0, -0.1, -0.1, 0, 0, 0, -1}
filter := [10]float32{-1, 4: -0.1, -0.1, 9: -1}</code></pre>

在类型为 map[K]V 的映射 a 中，下标表达式可使用特殊形式
<pre><code>v, ok = a[x]
v, ok := a[x]
var v, ok = a[x]</code></pre>
赋值或初始化，该下标表达式结果的类型为`(V, bool)`的值对。 在此形式中，若键`x`已在映射中，则`ok`的值为`true`， 否则即为`false`。`v`的值为`a[x]`的单值形式。

（`x`必须为接口类型。）若`T`为非接口类型，`x.(T)`断言`x`的动态类型与`T`相同。在此情况下，`T`必须实现`x`的（接口）类型，除非其类型断言由于无法为`x`存储类型为`T`的值而无效。若`T`为接口类型，`x.(T)`则断言`x`的动态类型实现了接口`T`。

若类型断言以
<pre><code>v, ok = x.(T)
v, ok := x.(T)
var v, ok = x.(T)</code></pre>
的形式用于赋值或初始化，该断言的结果即为类型为`(T, bool)`的值对。 若该断言成立，该表达式返回值对`(x.(T), true)`；否则，该表达式返回`(Z, false)`，其中`Z`为类型为`T`的零值。此种情况不会产生运行时恐慌。

除移位操作外，若其中一个操作数为无类型化常量而另一个不是， 该常量需类型转换为另一个操作数的类型。

移位表达式中的右操作数必须为无符号整数，或可转换为无符号整数的无类型化常量。 若非常量移位表达式的左操作数为无类型化常量，且该移位表达式已被其左操作数独自取代， 则该移位表达式的类型将变为该常量的类型；若其类型不能从上下文中判定 （例如，若该移位表达式在针对无类型化常量的比较操作中），则为 int类型。

一元操作符拥有最高优先级。`++`和`--`操作符是语句，而非表达式，它们不属于运算符一级。 因此，语句`*p++`等价于`(*p)++`。

若被除数`x`为`x`的`int`类型的最小负值，商`q = x / -1`等于`x`（且`r = 0`）。

切片、映射或函数值可与预声明标识符`nil`进行比较。

从`nil`信道接收将永远阻塞。从已关闭的信道接收将总是成功， 它会立刻返回其元素类型的零值。

在已关闭信道上进行发送会引发一个运行时恐慌。 在`nil`信道上进行发送将永远阻塞。

当转换浮点数(非常量数值类型)为整数时，小数部分将被丢弃（向零截断）。

当对一个表达式、赋值或Return语句进行求值时， 所有函数调用、方法调用以及通信操作均按从左到右的词法顺序求值。

函数`copy`将切片元素从来源`src`复制到目标`dst`并**返回复制的元素数量**。

若映射`m`为`nil`或元素`m[k]`不存在，则`delete`就是一个空操作。

即使在单个源文件中，一个包也可能包含多个`init`函数，它们会按照不确定的顺序执行。
